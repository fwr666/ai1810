1.fork()创建子进程特点
1.子进程会复制父进程全部的内存空间和代码段
2、子进程会fork的下一句开始执行
3.if elif else结构正是根据父进程fork的返回
   值不同让父子进程执行不同的内容，几乎是
   fork的固定搭配

   4.父子进程运行互不影响，使用同一终端，运行顺序不定
                                            5.子进程有自己特有的PID,PCB,命令集等 
   6.进入阻塞状态的进程一定会让出cpu时间片  
   定义变量；开辟空间   
   7.子进程连同fork之前开辟的空间也会复制。
     但是父子进程各自空间独立，操作各个空间内容 互不影响 

     os.getpid()
     功能：获取进程的pid
     返回值：pid号

     os.getppid()
     功能：获取父进程的pid号
     返回值：返回 父进程PID

     os._exit(status)
     功能：退出一个进程
      参数： 表示进程退出状态  整数
                  
     无返回值

     sys.exit([status])
           参数：默认为0  表示进程退出状态  整数
                  字符串  则在程序退出时打印该字符串
   三、孤儿进程和僵尸进程
       孤儿进程：父进程先于子进程退出此时子进程称为孤儿进程
                         会被系统进程收养，此时系统进程成为该进程新的
			   父进程
	僵尸进程：子进程先于父进程退出，父进程没有处理
	                    子进程的退出状态，此时子进程就会成为僵尸进程，
	
	*僵尸进程虽然结束但是会存留部分pcb 在内存，大量僵尸进程会占用
	         内存资源

	如何处理僵尸进程
	   1.在父进程中使用函数处理子进程退出状态
	       pid,status = os.wait()
	       功能：阻塞等待处理子进程退出
	       返回值：pid 退出的子进程的pid
	                       status  子进程的退出状态
	      pid,status = os.waitpid(pid,option)
	      功能： 阻塞等待处理子进程退出
	      参数：pid -1  子进程的退出状态 
	                       >0  等待指定pid 的子进程退出
			    option 0   表示阻塞等待
			               WNOHANG   表示非阻塞

	      返回值： pid 退出的子进程的pid
	      status  子进程的退出状态
	   2. 创建二级子进程
	       1）、父进程创建子进程等待子进程退出
	       2）、子进程创建二级子进程后立即退出
	       3）、将事件交由父进程和二级子进程完成
	                  一级子进程被回收，二级子进程成为孤儿
			  保护变成僵尸进程

确定需求->基本的技术分析--》整体设计---》功能分析
                 ----》代码实现----》代码测试完善

		 如果父进程先创建对象再创建子进程，则子进程从父进程获取
		对象，此时父子进程在对象操作上有一定的相互影响
		e.g. 套接字会监听一个端口，文件会有一个偏移量

		在各自进程创建对象则没有影响












